# 🧠 해시테이블(Hash Table) 핵심 요약

---

## 1️⃣ 기본 개념

- **정의:**  
  Key–Value 쌍을 저장하는 자료구조.  
  Key를 **해시 함수(hash function)** 로 숫자로 바꿔 배열의 인덱스로 변환한 뒤 값을 저장함.
- **대표 사용 예:**  
  파이썬의 `dict`, 자바의 `HashMap`, 자바스크립트의 `Object`.

---

## 2️⃣ 기본 구조

| 구성요소         | 설명                                     |
| ---------------- | ---------------------------------------- |
| **해시 함수**    | key를 정수로 변환하는 함수 (`hash(key)`) |
| **버킷(bucket)** | 데이터를 저장하는 배열의 각 칸           |
| **인덱스 계산**  | `index = hash(key) % table_size`         |
| **저장 데이터**  | `(key, value)` 형태로 저장               |

---

## 3️⃣ 동작 원리

### ✔️ 삽입 (Insert)

1. `hash(key)` 계산
2. `index = hash(key) % table_size`
3. 인덱스가 비어있으면 저장, 이미 있다면 **충돌 처리**

### ✔️ 조회 (Search)

1. `hash(key) % table_size` 계산
2. 해당 버킷에서 key 비교 (`==`)
3. 일치하면 value 반환, 없으면 탐사 계속

### ✔️ 삭제 (Delete)

- 해당 인덱스의 데이터를 제거하고, 삭제 표시(`deleted flag`) 남김

---

## 4️⃣ 해시 충돌(Collision)

> 서로 다른 키가 같은 인덱스에 매핑되는 현상

### 충돌 해결 방식

| 방식                              | 원리                                      | 특징                              |
| --------------------------------- | ----------------------------------------- | --------------------------------- |
| **체이닝 (Chaining)**             | 같은 인덱스에 연결리스트로 여러 항목 저장 | 구현 쉬움, 메모리 사용 많음       |
| **개방 주소법 (Open Addressing)** | 빈 칸을 찾아 다음 인덱스에 저장           | 메모리 효율적, 충돌 많으면 느려짐 |

---

## 5️⃣ 개방 주소법의 탐사(Probing)

| 방식                           | 탐사 함수 f(i)               | 설명                          |
| ------------------------------ | ---------------------------- | ----------------------------- |
| **선형 탐사**                  | `i`                          | 한 칸씩 순차 이동             |
| **제곱 탐사**                  | `i²`                         | 점점 멀리 이동                |
| **이중 해싱**                  | `i * hash2(key)`             | 두 번째 해시로 점프 간격 결정 |
| **Perturbation (파이썬 dict)** | 해시 비트를 섞어 불규칙 탐사 | 충돌 분산에 효과적            |

📌 **저장과 조회 모두 동일한 탐사 순서 사용**  
→ 충돌로 밀린 데이터도 정확히 찾아낼 수 있음.

---

## 6️⃣ 리사이징(Resizing) & 리해싱(Rehashing)

| 개념         | 설명                                                          |
| ------------ | ------------------------------------------------------------- |
| **리사이징** | 테이블이 70~80% 차면 크기를 두 배로 확장                      |
| **리해싱**   | 확장 후 모든 key에 대해 `index = hash(key) % new_size` 재계산 |
| **이유**     | 새로운 크기로 나머지를 계산해야 균등한 분포 유지              |

🔹 파이썬 `dict`는 **2의 거듭제곱 크기**로 확장 (8 → 16 → 32 → 64 …)  
🔹 리사이징은 C 레벨에서 빠르게 수행되어 사용자는 거의 느끼지 못함.

---

## 7️⃣ 시간 복잡도

| 연산 | 평균 | 최악 (충돌 심할 때) |
| ---- | ---- | ------------------- |
| 삽입 | O(1) | O(n)                |
| 조회 | O(1) | O(n)                |
| 삭제 | O(1) | O(n)                |

> 평균적으로 O(1) — 상수 시간 접근이 가능  
> (충돌이 많을 때만 O(n)으로 저하)

---

## 8️⃣ 파이썬 dict 내부 동작

| 항목                    | 내용                                 |
| ----------------------- | ------------------------------------ |
| **구조**                | 개방 주소법 + perturbation 기반 탐사 |
| **버킷 개수**           | 2의 거듭제곱 단위 (8, 16, 32, …)     |
| **적재율(load factor)** | 약 2/3 초과 시 자동 리사이징         |
| **순서보장**            | Python 3.7+ 부터 삽입 순서 유지      |
| **성능특징**            | 평균 O(1) 접근, 충돌 최소화 설계     |

---

## 9️⃣ 한눈 정리

```
index = hash(key) % table_size

┌────────────────────────────┐
│ 해시 함수 계산 │
│ key → hash(key) │
└────────────┬───────────────┘
↓
나머지 연산 (% table_size)
↓
┌────────────────────────────┐
│ 버킷 배열(Table) │
│ [0][1][2][3][4][5][6][7] │
│ ↑ │
│ 인덱스로 접근 │
└────────────────────────────┘
```

> ✅ 충돌 → 탐사로 해결  
> ✅ 테이블 크기 변경 시 재해싱  
> ✅ 평균 O(1) 성능 유지

---

## 🔚 핵심 키워드

> 해시(Hash) · 충돌(Collision) · 탐사(Probing) · 체이닝(Chaining)  
> 개방주소법(Open Addressing) · 리사이징(Resizing)  
> 리해싱(Rehashing) · 적재율(Load Factor)

---
